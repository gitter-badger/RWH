### 2장 타입과 함수

##### 왜 **타입**에 신경쓰는가?
- 하스켈의 _모든 표현식과 함수는 **타입** 을_ 가짐.
- 값이 어떤 타입을 갖는 다는 것은 어떤 특성들을 해당 타입의 다른 값들과 공유함을 의미.
- Q: 왜 타입에 신경써야 하며, 타입은 무엇을 위해 존재하는가?
  - A : 추상화 (abstraction) 제공을 위해 존재.
  - 컴퓨터는 구조가 거의 없는 바이트 열을 다룸. 
  - 타입은 바이트 열에 특정 의미를 부여하여 추상화(abstraction) 제공.
  - 추상화 도입은 저수준 디테일에 신경을 덜 쓰게 되는 잇점을 가져옴.
- 모든 타입 시스템은 다 다르고, 이런 다른 타입 시스템들은 다른 문제에 신경쓰고 있는 것임
- 프로그래밍 언어의 타입 시스템은 우리의 생각과 코드 작성에 영향을 끼침
- 하스켈의 타입 시스템은 우리가 높은 추상성으로 생각하도록 함
- 높은 추상화 수준의 사고법은 간결하고 강력한 코드를 작성하게 해 줌.
 
##### 하스켈의 타입 시스템
* 강한 타입 Strong types
  - 하스켈이 strong type system 을 가지고 있다는 말이 의미하는 내용들
    - 타입이 맞지 않아서 생기는 의미 없는 표현식이 존재하지 않는 다는 것을 보장.
      - 하스켈 컴파일러는 ill typed 표현식에 대한 에러를 모두 잡아 줌.
      - 언어의 타입 규칙을 따르는 표현식을 well typed 라고 하고
      - 언어의 타입 규칙을 따르지 않는 표현식을 ill typed 라고 함.
    - 자동 타입 변환을 하지 않음.
  - strong type 의 장.단점
    - [단점] 효율 좋은 시리얼라이제이션 코드는 strong type 에서 작성하기가 더 어려움.
    - [장점] 타입 관련 에러는 문제를 일으키기 전에 인지됨.
  - 'strong and weak type' 용어 정의 관련
    - 프로그램 커뮤니티들 모두 제각각의 정의를 하고 있다. 
    - 학계에서는 타입 시스템이 
      - 얼마나 관대하냐를 의미하는 strength 를 좁게 정의하고 
      - strength의 강약으로 stronger, weaker 를 상대적으로 정의할 뿐임.
* 정적 타입 Static types
  - 의미 : 코드 수행 전에 컴파일러가 모든 값과 표현식의 타입을 알 수 있음.
  - ex) "false" || True 표현식이 ill type 라는 것을 감지하고 에러 출력.
  - 감지하는 것은 static 특성, 컴파일 거부하는 것은 strong 특성
  - 단점 : "duck typing" 등과 같은 유용한 코드 작성을 어렵게 한다.
    - duck typing : "만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다."
    - duck typing : 어떤 오브젝트가 특정 타입에 걸맞은 변수와 메소드를 지니면 그 오브젝트를 특정 타입에 속하는 것으로 간주함.
  - haskell typeclass : 다이나믹 타이핑의 대부분의 장점을 안전하고 편리한 방식으로 제공
  - strong + static type
    - runtime type error 발생이 불가능.
    - 미리 고려해야 될 것들이 조금 있기는 함.
    - 동적 타입 언어 에서는
      -  타입 에러 없음 확인을 위해 필요한 작업은 꽤 많음.
      -  더구나, 리팩토링 등의 작업 이후에는 타입 에러 체킹 재작업 필요.
  - 동적타입 vs 정적 타입 : 정사각형 조각의 직소 퍼즐 vs 일반 직소 퍼즐
* 타입 추론 Type inference
  - 거의 대부분의 표현식에 대해 하스켈 컴파일러는 타입 추론 가능
  - 하스켈에서 명시적 타입 지정도 가능하지만, 컴파일러 추론 능력으로 명시적 지정은 옵션임

##### 타입 시스템에서 얻을 수 있는 것은?
- 처음에는 타입 시스템이 성가실 것이다.
  - 코드의 동작 방식만 맞으면 동작하는 파이썬이나 루비와 달리 타입체커의 정밀검사를 통과해야 함.
- 하스켈 타입 시스템의 장점: 강력함 
  - strong, static 타입은 안전한 코드를 만들고
  - 타입 추론은 간결한 코드를 만들어서
  - 기존 정적 언어보다 더 안전하고
  - 기존 동적 언어보다 더 표현력이 좋다.
- tradeoff - 하스켈 타입 시스템 프레임워크를 배워야 함.
  - 하스켈 타입의 새로운 사용법을 책 전반에 걸쳐 소개할 예정.
  - 타입 시스템의 가치는 점점 모습을 드러낼 것임.
  - 각 부분에서 보여지는 장점들의 합보다 훨씬 큰 장점이 마지막에는 드러남.

##### 몇 가지 기본 타입 (some common basic types)
- 가장 흔하게 사용하는 기본 타입들 중 일부 소개.
  - Char : 유니코드 문자를 표현
  - Bool : 불리안 로직의 값을 표현. True, False 두 개의 값이 가능
  - Int :  부호 있는 고정 크기(최소 28비트) 정수 값 표현. 일반적으로 머신 bits 수를 따름.
  - Integer : 제약 없는 크기의 부호 있는 정수 표현. 오버플로우 문제는 없으나 성능은 Int 에 비해 떨어짐.
  - Double : 64비트 부동 소수 표현. float 은 Double 보다 느리게 구현되어 있어서 사용이 장려되지 않음.
- type signature
  - expression::type 형태에서 '::type' 부분을 뜻함.
  - 특정 표현식이 갖는 타입을 타입 시그너처를 통해 명시할 수 있으나,
  - 타입 시그너처를 생략할 수도 있고, 생략하면 컴파일러가 유추함.

##### 함수 적용 (Function application)
- 지금까지 살펴본 데이터 타입들에 대해 함수를 가지고 할 수 있는 일들.
- 함수 적용 시 괄호 필요 없음.
- 함수 적용은 연산자 적용보다 우선 순위가 높음.
  - compare 2 3 == LT 는  (compare 2 3) == LT 을 의미함.

##### 유용한 복합 데이터 타입: lists and tuples

##### list와 tuple에 적용 가능한 함수들
* 함수에 표현식 전달하기

##### 함수 타입과 순수성 Function types and purity

##### 하스켈 소스 파일, 간단한 함수 작성
* 변수란? (Just what is a variable, anyway?)
* 조건 계산 (Conditional evaluation)

##### 예제로 계산 과정(evaluation) 이해하기
* 지연 계산법 (Lazy evaluation)
* 관련 예제들 (A more involved example)
* 재귀 (Recursion)
* 재귀 끝내기 (Ending the recursion)
* 재귀에서 리턴하기 (Returning from the recursion)
* 배운 것들 리뷰

##### 하스켈에서의 다형성
* 다형 함수에 대한 추론
  * 더 읽어볼 것들

##### 인자가 두 개 이상인 함수의 타입

##### 순수성에 깊은 관심을 갖는 이유

##### 결론
